

//type i32 = int32_t

type MyStruct = (
    a: int
    b: int
)

//fn CreateOnStack = (a: i32) -> MyStruct {
//    (a, a)
//}

fn Print = (s : MyStruct) -> () {
    printf("a: %d, b: %d\n", s.a, s.b)
    0
}

fn PrintSubfield = (a: int) -> () {
    printf("a: %d\n", a)
    0
}

// First going to get returning from functions working...
// Then going to make structs work?

fn main = () -> int {
    let x = "hello world"

    let y : MyStruct = (2, 3)

    Print(y)
    PrintSubfield(y.a)

    // How does this mesh with casting? (Which is important for numerical stuff)
    // This is my fave - matches the declaration, also matches the way you pass to functions....
    //let x_on_the_stack: MyStruct = (2, 3) // or { (2, 3) } to make it block expr? 
    //let x_on_the_stack_from_func = CreateOnStack(13) // or { (2, 3) } to make it block expr? 
    // Print(x_on_the_stack)
    //Print((2, 3))
    //Print(CreateOnStack(3))

     // I actually don't like this because it isn't the same as the declaration or function params,
     // which are name : type
    // let x_on_the_stack: MyStruct = (a: 2, b: 3)

    // let x_on_the_heap : MyStruct = mem::HeapAlloc<MyStruct>((2, 3)) // How to take struct by rvalue?
//    Print(x_on_the_stack) // Use them the same way, always pointer under the hood
    //Print(x_on_the_heap)


    printf("%s\n", x)
    x
}


